# 5.1 计算机体系结构和内存层次

## 操作系统的内存管理方式

- 重定位（relocation）
- 分段（segmentation）
- 分页（paging）
- 虚拟存储（virtual memory）
  - 多数系统（Linux）采用按需页式虚拟存储

# 5.2 地址空间和地址生成

## 地址空间定义

- 物理地址空间——硬件支持的地址空间
- 逻辑地址空间——CPU运行的进程看到的地址

## 逻辑地址生成

符号->编译->符号->汇编->地址编号/符号->链接->地址编号->程序加载（重定位）

## 地址生成时机和限制

- 编译时
  - 假设地址已知
  - 起始地址改变，必须重新编译

- 加载时
  - 编译时起始地址未知，编译器需生成可重定位的代码（relocatable code）
  - 加载时生成绝对地址。

- 执行时
  - 执行时代码可移动
  - 需地址转换（映射）硬件支持

## 地址生成过程

- CPU
  - ALU：需要逻辑地址的内存内容
  - MMU：进行逻辑地址和物理地址的转换
  - CPU 控制逻辑：给总线发物理地址请求

- 内存
  - 发送物理地址的内容给 CPU
  - 或接收 CPU 数据到物理地址
- 操作系统
  - 建立逻辑地址 LA 和物理地址 PA 的映射。（页表）

## 地址检查

1. 检查段的长度和偏移量

操作系统可以设置起始和最大逻辑地址空间。

# 5.3 连续内存分配

## 连续内存分配和内存碎片

- 内存碎片
  - 空闲内存不能被利用
- 外部碎片
  - 分配单元之间的未被使用内存
- 内部碎片
  - 分配单元内部的未被使用内存
  - 取决于分配单元大小是否要取整

## 连续内存分配：动态分区分配

动态分区分配

- 操作系统需要维护的数据结构
  - 所有进程的已分配分区
  - 空闲分区

- 动态分配策略
  - 最先匹配
  - 最佳匹配
  - 最差匹配

## 最先匹配策略

- 思路

分配 n 个字节，使用第一个可用的空间比 n 大的空闲块。

- 原理/实现
  - 空闲分区列表按地址顺序排序
  - 分配过程时，搜索第一个合适的分区
  - 释放分区时，检查是否可与临近的空闲分区合并
- 优点
  - 简单
  - 在高地址空间有大块的空闲分区
- 缺点
  - 外部碎片
  - 分配大块时较慢

## 最佳匹配策略

- 思路

分配 n 字节分区时，查找并使用不小于 n 的最小空闲分区

- 原理/实现
  - 空闲分区列表按照大小排序
  - 分配时，查找一个合适的分区
  - 释放时，查找并且合并临近的空闲分区（如果找到）
- 优点
  - 大部分分配的尺寸较小时，效果很好
    - 可避免大的空闲分区被拆分
    - 可减小外部碎片的大小
    - 相对简单
- 缺点
  - 外部碎片
  - 释放分区较慢
  - 容易产生很多无用的小碎片

## 最差匹配

- 思路

分配 n 字节，使用尺寸不小于 n 的最大空闲分区

- 原理/实现
  - 空闲分区列表按由大到小排序
  - 分配时，选最大的分区
  - 释放时，检查是否可与临近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序。
- 优点
  - 中等大小的分配较多时，效果最好
  - 避免出现太多的小碎片
- 缺点
  - 释放分区较慢
  - 外部碎片
  - 容易破坏大的空间分区，因此后续难以分配大的分区。

# 5.4 碎片整理

## 碎片整理：紧凑（compaction）

- 碎片整理
  - 通过调整进程占用的分区位置来减少或避免分区碎片

- 碎片紧凑
  - 通过移动分配给进程的内存分区，以合并外部碎片
  - 碎片紧凑的条件
    - 所有的应用程序可动态重定位
  - 需要解决的问题
    - 什么时候移动？
    - 开销

## 碎片整理：分区对换（Swapping in/out）

- 通过抢占并回收处于等待状态进程的分区，以增大可用内存空间

- 需要解决的问题
  - 交换哪个（些）程序

# 5.5 伙伴系统(Buddy System)

连续内存分配的一个实例

- 整个可分配的分区大小是 $2^U$

- 需要的分区大小为 $2^{U-1}<s \leq 2^U$ 时，把整个块分配给该进程；
  - 如果 $s \leq 2^{i-1}-1$，将大小为 $2^i$ 的当前空闲分区划分成两个大小为 $2^{i-1}-1$ 的空闲分区
  - 重复划分过程，直到 $2^{i-1}<s \leq 2^i$，并把一个空闲分区分配给该进程。

## 伙伴系统的实现

- 数据结构
  - 空闲块按大小和起始地址组织成二维数组
    - 第一维是空闲块的大小，空闲块由小到大排序。
    - 第二维是地址，相同大小的空闲块按照地址排序。
  - 初始状态：只有一个大小为 $2^U$ 的空闲块
- 分配过程
  - 由小到大在空闲块数组中找最小的可用空闲块
  - 如空闲块过大，对可用空闲块进行二等分，直到得到合适的可用空闲块

- 释放过程
  - 把释放的块放入空闲块数组
  - 合并满足合并条件空闲块
- 合并条件
  - 大小相同 $2^i$
  - 地址相邻
  - 起始地址较小的块的起始地址必须是 $2^{i+1}$ 的倍数

Buddy System 在 Unix 系列系统中主要是用来做内核里的存储分配

## 伙伴系统中的内存分配

## ucore 中的物理内存管理

接口：

```c
struct pmm_manager {
    // XXX_pmm_manager's name
    const char *name;
    // initialize internal description&management data structure
    // (free block list, number of free block) of XXX_pmm_manager
    void (*init)(void);
    // setup description&management data structcure according to
    // the initial free physical memory space
    void (*init_memmap)(struct Page *base, size_t n);
    // allocate >=n pages, depend on the allocation algorithm
    struct Page *(*alloc_pages)(size_t n);
    // free >=n pages with "base" addr of Page descriptor structures(memlayout.h)
    void (*free_pages)(struct Page *base, size_t n);
    size_t (*nr_free_pages)(void);      // return the number of free pages 
    void (*check)(void);                // check the correctness of XXX_pmm_manager 
};
```



## 参考资料

https://en.wikipedia.org/wiki/Buddy_memory_allocation

# 练习

在使能分页机制的情况下，更合适的外碎片整理方法是()

- [ ] 紧凑(compaction)

- [ ] 分区对换(Swapping in/out)

- [x] 都不是

> 分页机制不会出现外碎片

描述伙伴系统(Buddy System)特征正确的是()

- [x] 多个小空闲空间可合并为大的空闲空间
- [x] 会产生外碎片
- [x] 会产生内碎片
- [ ] 都不对

> 前三个都是对的